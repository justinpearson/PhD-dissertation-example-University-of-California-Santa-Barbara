
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Quasi-optimality of Event-based control}
\label{sxn:event-driven-encoders}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Parts of this chapter come from \cite{PearsonHespanhaLiberzonMay2017}:

2017 IEEE. Reprinted, with permission, from J. Pearson, J. Hespanha, D. Liberzon. Control with minimal cost-per-symbol encoding and quasi-optimality of event-based encoders. IEEE Trans. on Automat. Contr., 62(5):2286--2301, May 2017.




In the last chapter we constructed an $N$-of-$M$
encoding scheme that stabilizes \theprocess{} provided that the
bit-rate and average cost condition \eqref{eq:pos-lim-energy}
holds. This scheme may be difficult to implement in practice if the
encoder/decoder pair use a large number of codewords. In this section
we present an \emph{event-based} encoding scheme that is easy to
implement and does not require storing a large
set of codewords. Instead, it uses a library of only three symbols
$\{-1,0,1\}$ and does not group them into codewords. The basic idea is
to monitor in parallel each one-dimensional component of the error
system, and as long as it stays
inside a fixed interval, send the free symbol $0$. 

...





\section{Definition of the event-based scheme}

Unlike the scheme
from Section \ref{sxn:sufficient-condition}, this scheme differs in
what symbols are sent and how the state estimate $\hat x$ is updated:

...

\section{Conclusion}

In this chapter examined an event-based controller based on the framework from Chapter~\ref{chap:mineng}. We proved its \bitrate{} requirements were
order-optimal with respect to the necessary and sufficient condition
for stabilizability from Chapter~\ref{chap:mineng}. This supports the use of
event-based controllers in limited-communication control schemes.

...